---
title: "DeepResearch-Like RAG Workflow"
icon: "flask"
---

In real-world applications, user questions often contain ambiguous, generalized, or knowledge points that require multi-turn supplementation. Traditional one-time retrieve + generate (RAG) workflows often struggle to answer such questions accurately. To address this, DeepResearch proposes a RAG workflow with more “research-style thinking” features: before answering, the model first plans, actively identifies missing information, generates sub-questions in stages, and constructs a complete information framework through multiple rounds of “search - reasoning - page updating,” ultimately producing high-quality answers.

In this section, we will implement a DeepResearch-like system based on the UltraRAG framework. This system guides the model to generate an overall structure plan (Plan) and initial page (Page) according to the original question, and then, through multiple rounds of sub-question generation and retrieval, iteratively fill and refine the page to construct a knowledge page closely related to the question.

## Step 1: Clarify the Workflow Structure

This algorithm includes the following key stages:

1. Initialization of planning and page structure

The large model generates a complete Plan (structured page planning) based on the original question, and builds an initial page with [to be filled] placeholders.

Example input:

```markdown
Question: Who does the singer of "Night Rocker" play in "Melody of Desire"?
```

Example Plan:

Plan:

```json
{
  "mainTitle": "Identifying the singer of 'Night Rocker' and their role in 'Melody of Desire'",
  "sections": [
    {
      "title": "Understanding the Song and Its Singer",
      "focus": "This section identifies the singer of 'Night Rocker' and provides background information about the artist.",
      "subtopics": [
        "Overview of the song 'Night Rocker'",
        "Identity confirmation of the singer related to this song"
      ]
    }... 
```
Initial page:

Initial page:

```markdown
# Identifying the singer of 'Night Rocker' and their role in 'Melody of Desire'
## Understanding the Song and Its Singer
[to be filled]
## Overview of 'Melody of Desire'
[to be filled]
## The Singer's Role in 'Melody of Desire'
[to be filled]
```

2. Enter the iterative process

In each round, the model:

  - Decomposes the current to-be-filled content and generates sub-questions
  - Retrieves documents for the sub-questions
  - Updates the corresponding section of the page based on the current Plan, page, and document content

This process continues until:
  - There is no [to be filled] content left in the page
  - Or the maximum number of iterations is reached (default is 10 rounds)

## Step 2: Implement the Required Tools

### Step 2.1: Implement Prompt Server Functions

Prompt templates are located in the prompt/ directory. Functions are implemented in servers/prompt/src/prompt.py. Each function is bound to a template file and must be registered as a separate field in parameter.yaml (to avoid conflicts):

```python
@app.prompt(output="q_ls,plan_ls,webnote_init_page_template->prompt_ls")
def webnote_init_page(
    q_ls: List[str],
    plan_ls: List[str],
    template: str | Path,
) -> List[PromptMessage]:
    template: Template = load_prompt_template(template)
    all_prompts = []
    for q, plan in zip(q_ls, plan_ls):
        p = template.render(question=q, plan=plan)
        all_prompts.append(p)
    return all_prompts

@app.prompt(output="q_ls,webnote_gen_plan_template->prompt_ls")
def webnote_gen_plan(
    q_ls: List[str],
    template: str | Path,
) -> List[PromptMessage]:
    template: Template = load_prompt_template(template)
    all_prompts = []
    for q in q_ls:
        p = template.render(question=q)
        all_prompts.append(p)
    return all_prompts

@app.prompt(output="q_ls,plan_ls,page_ls,webnote_gen_subq_template->prompt_ls")
def webnote_gen_subq(
    q_ls: List[str],
    plan_ls: List[str],
    page_ls: List[str],
    template: str | Path,
) -> List[PromptMessage]:
    template: Template = load_prompt_template(template)
    all_prompts = []
    for q, plan, page in zip(q_ls, plan_ls, page_ls):
        p = template.render(question=q, plan=plan, page=page)
        all_prompts.append(p)
    return all_prompts

@app.prompt(output="q_ls,plan_ls,page_ls,subq_ls,psg_ls,webnote_fill_page_template->prompt_ls")
def webnote_fill_page(
    q_ls: List[str],
    plan_ls: List[str],
    page_ls: List[str],
    subq_ls: List[str],
    psg_ls: List[str],
    template: str | Path,
) -> List[PromptMessage]:
    template: Template = load_prompt_template(template)
    all_prompts = []
    for q, plan, page, subq, psg in zip(q_ls, plan_ls, page_ls, subq_ls, psg_ls):
        p = template.render(question=q, plan=plan, page=page, subq=subq, psg=psg)
        all_prompts.append(p)
    return all_prompts

@app.prompt(output="q_ls,plan_ls,page_ls,webnote_gen_answer_template->prompt_ls")
def webnote_gen_answer(
    q_ls: List[str],
    plan_ls: List[str],
    page_ls: List[str],
    template: str | Path,
) -> List[PromptMessage]:
    template: Template = load_prompt_template(template)
    all_prompts = []
    for q, plan, page in zip(q_ls, plan_ls, page_ls):
        p = template.render(question=q, plan=plan, page=page)
        all_prompts.append(p)
    return all_prompts
```

The complete list of functions is as follows:

- webnote_gen_plan: Generate a structured Plan based on the question
- webnote_init_page: Construct the initial page based on the Plan
- webnote_gen_subq: Generate sub-questions
- webnote_fill_page: Fill the page content based on sub-question results
- webnote_gen_answer: Integrate the page information to generate the final answer

Each function corresponds to a .jinja template. Be sure to give each template a separate field name in parameter.yaml.

### Step 2.2: Implement Router Server Functions

This function checks whether the current page has been fully filled. If there are still [to be filled] or similar placeholders, it is marked as incomplete and the loop continues; otherwise, the process ends.

```python
@app.tool(output="page_ls->page_ls")
def webnote_check_page(page_ls: List[str]) -> Dict[str, List[Dict[str, str]]]:
    """Check if the page is complete or incomplete.
    Args:
        page_ls (list): List of pages to check.
    Returns:
        dict: Dictionary containing the list of pages with their states.
    """
    page_ls = [
        {
            "data": page,
            "state": "incomplete" if "to be filled" in page.lower() else "complete",
        }
        for page in page_ls
    ]
    return {"page_ls": page_ls}
```

## Step 3: Write the Pipeline Configuration File

Define the module structure and execution flow in examples/webnote.yaml as follows:

```yaml
servers:
  benchmark: servers/benchmark
  generation: servers/generation
  retriever: servers/retriever
  prompt: servers/prompt
  evaluation: servers/evaluation
  custom: servers/custom
  router: servers/router
  
# MCP Client Pipeline
pipeline:
# Initialize retrieval service
- retriever.retriever_init
- retriever.retriever_embed
- retriever.retriever_index
- generation.initialize_local_vllm
# Load dataset
- benchmark.get_data
# Generate plan
- prompt.webnote_gen_plan
- generation.generate:
    output:
      ans_ls: plan_ls
# Initialize page
- prompt.webnote_init_page
- generation.generate:
    output:
      ans_ls: page_ls
# Loop: generate sub-questions, retrieve, fill page step by step
- loop:
    times: 10
    steps:
    # Trigger check, determine if page is complete
    - branch:
        router:
        - router.webnote_check_page
        branches:
          # If page is incomplete, continue
          incomplete:
          # Generate sub-questions
          - prompt.webnote_gen_subq
          - generation.generate:
              output:
                ans_ls: subq_ls
          # Retrieve answers
          - retriever.retriever_search:
              input:
                query_list: subq_ls
              output:
                ret_psg: psg_ls
          # Fill page
          - prompt.webnote_fill_page
          - generation.generate:
              output:
                ans_ls: page_ls
          # If page is complete, end
          complete: []
# Generate answer
- prompt.webnote_gen_answer
- generation.generate
# Evaluate result
- custom.output_extract_from_boxed
- evaluation.evaluate
```

## Step 4: Configure Pipeline Parameters

Run the following command to build the parameter template:

```shell
ultrarag build examples/webnote.yaml
```

Then edit the generated parameter/webnote_parameter.yaml to ensure the parameter settings are as expected. For example:

```yaml
prompt:
  webnote_gen_plan_template: prompt/webnote_gen_plan.jinja
  webnote_init_page_template: prompt/webnote_init_page.jinja
  webnote_gen_subq_template: prompt/webnote_gen_subq.jinja
  webnote_fill_page_template: prompt/webnote_fill_page.jinja
  webnote_gen_answer_template: prompt/webnote_gen_answer.jinja
```

If you do not give each template an explicit field name in parameter.yaml and instead use template:, it may lead to parameter conflicts during the build phase.

The format of webnote_parameter.yaml is as follows:

```yaml
benchmark:
  benchmark:
    key_map:
      gt_ls: golden_answers
      q_ls: question
    limit: 2
    name: asqa
    path: data/sample_asqa_5.jsonl
custom: {}
evaluation:
  metrics:
  - acc
  - f1
  - em
  - coverem
  - stringem
  - rouge-1
  - rouge-2
  - rouge-l
  save_path: output/asqa.json
generation:
  api_key: ''
  base_url: http://0.0.0.0:8021/v1
  gpu_ids: '6'
  model_name: model/Qwen2.5-7B-Instruct
  port: 8021
  sampling_params:
    extra_body:
      chat_template_kwargs:
        enable_thinking: false
      include_stop_str_in_output: true
      top_k: 20
    max_tokens: 2048
    temperature: 0.7
    top_p: 0.8
prompt:
  webnote_fill_page_template: prompt/webnote_fill_page.jinja
  webnote_gen_answer_template: prompt/webnote_gen_answer.jinja
  webnote_gen_plan_template: prompt/webnote_gen_plan.jinja
  webnote_gen_subq_template: prompt/webnote_fill_page.jinja
  webnote_init_page_template: prompt/webnote_init_page.jinja
retriever:
  corpus_path: data/sample_hotpotqa_corpus_5.jsonl
  cuda_devices: '4'
  embedding_path: embedding/embedding.npy
  faiss_use_gpu: false
  index_chunk_size: 50000
  index_path: index/index.index
  infinity_kwargs:
    batch_size: 1024
    bettertransformer: false
    device: cuda
    pooling_method: auto
  overwrite: false
  query_instruction: 'Query: '
  retriever_path: model/bge-large-en
  top_k: 5
  use_openai: false
```

## Step 5: Run Your Reasoning Workflow!

Once everything is ready, run the following command to start the reasoning workflow:

```shell
ultrarag run examples/webnote.yaml
```