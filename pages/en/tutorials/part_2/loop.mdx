---
title: "Loop Structure"
icon: "rotate-right"
---

In many multi-turn reasoning, multi-hop QA, and multi-turn retrieval tasks, a single execution of the workflow is often insufficient to obtain the final answer. In these cases, you need to use a **loop structure** to repeatedly execute certain modules, iteratively refine information, and improve the generated results step by step.

## Example: Multi-turn Sub-question Generation and Retrieval Workflow

Below is a typical multi-turn RAG reasoning workflow. Each round includes:

1. Perform retrieval based on the current question or context;
2. Generate a new sub-question based on the retrieved results;
3. Call a large language model (LLM) to generate the response.

We set the process to run up to 3 rounds, then finally generate the final answer.

```yaml
pipeline:
  - benchmark.get_data
  - retriever.retriever_init
  - loop:
      times: 3         
      steps:
        - retriever.retriever_search
        - prompt.generate_subquery
        - generation.generate
        
  - prompt.generate_final_answer
  - generation.generate
```

## Explanation

- **loop**: Declares a loop block, indicating the subsequent steps will be executed repeatedly;
- **times**: Sets the maximum number of iterations (3 times in the above example);
- **steps**: Defines the sequence of tool calls in each round, with the same syntax as serial structure.

By default, the loop exit logic is based on a fixed number of iterations (i.e., exit after running `times` rounds). If you want to dynamically decide whether to exit the loop based on model output, you can use it in combination with the **branch structure** and Router Server, as explained in the next section.