---
title: "Data Flow and Parameter Binding Mechanism"
icon: "arrows-split-up-and-left"
---

In UltraRAG, the pipeline achieves data binding via variable names: each tool is registered with its own input parameter names and output variable names, and every step in the pipeline passes data using these variable names.

This mechanism is simple and straightforward, but in multi-turn calls or complex control structures (such as loop or branch), it can result in variable name conflicts or duplicate bindings. To solve this, UltraRAG provides a **parameter rewriting mechanism** (parameter renaming), allowing you to flexibly control how data flows through the pipeline.

## How Does Data Flow?

When registering each tool in the Server, you specify its input and output variable names. For example:

```python
mcp_inst.tool(
    self.retriever_search,
    output="q_ls,top_k->ret_psg",
)
```

This means:

- The tool receives two input variables: `q_ls` and `top_k`
- The tool outputs a variable named `ret_psg`

In the simplest serial pipeline, this default binding is fine. But if you want to call `retriever_search` multiple times in a loop or branch and wish to pass different data (for example, the first time as `q_ls`, the second time as `sub_q_ls`), you need a way to tell the pipeline: these variables are actually "synonyms".

## Parameter Renaming Mechanism

To resolve variable name binding conflicts as above, UltraRAG provides the following mechanism:

UltraRAG supports using `input:` and `output:` in `pipeline.yaml` to explicitly rename arguments and map variables, **without needing to modify any server code**.

**Basic Syntax**

```yaml
- module.tool:
    input:
      tool_param_name: actual_variable_name
    output:
      actual_variable_name
- tool_param_name: The parameter name as defined in the tool's registration
- actual_variable_name: The variable name available in the current pipeline context
- output: Allows you to rename the tool's output as any new variable name in the pipeline
```

## Example 1: Rename Input Variable

```yaml
- retriever.retriever_search:
    input:
      q_ls: sub_q_ls
```

Explanation: `retriever_search` originally expects an input parameter named `q_ls`, but here you are using the variable `sub_q_ls`. This statement maps the parameters, and you don't need to modify the server code.

## Example 2: Rename Output Variable

```yaml
- retriever.retriever_search:
    output: round1_result
```

Explanation: Whatever the tool's original output variable name (for example, `ret_psg`), it will now be bound as `round1_result` for use in subsequent pipeline steps.

For example:

```yaml
- prompt.qa_rag_boxed:
    input:
      ret_psg: round1_result
```

The `qa_rag_boxed` tool expects an input parameter named `ret_psg`. Here, we explicitly map the previous stage's `round1_result` to its `ret_psg` using `input:`, achieving data binding.

## Example 3: Rewrite Both Input and Output

```yaml
- retriever.retriever_search:
    input:
      q_ls: round1_query
    output: round1_result
```

This pattern is common in loops, where each retrieval round uses new variable names.

With the parameter rewriting mechanism, you can flexibly compose and reuse any Tool provided by a Server, making UltraRAG's pipeline much more extensible and controllableâ€”all without modifying the underlying tool code.