---
title: "Prompt Server"
icon: "terminal"
---

## What is Prompt Tool

Prompt Tool is a component in UR-2.0 used to construct inputs for language models. Each Prompt Tool is defined with the `@app.prompt` decorator. Its main responsibility is to load template files and generate standardized `PromptMessage` objects based on inputs such as questions and retrieved passages. These messages can be directly sent to LLM models for generation.

## How to Implement a Prompt Tool?

Implementing a Prompt Tool usually involves the following three steps:

### Step 1: Prepare the Prompt Template

Save your prompt template as a file with a `.jinja` extension, for example:

```jinja prompt/qa_rag_boxed.jinja icon="/images/jinja.svg"
Please answer the following question based on the given documents.
Think step by step.
Provide your final answer in the format \boxed{YOUR_ANSWER}.

Documents:
{{documents}}

Question: {{question}}
```

### Step 2: Implement the Tool in Prompt Server

Use our provided `load_prompt_template` method to load the template, and implement a tool function (Tool) in the Prompt Server to assemble the prompt:

```python servers/prompt/src/prompt.py icon="python"
@app.prompt(output="q_ls,ret_psg,template->prompt_ls")
def qa_rag_boxed(
    q_ls: List[str], ret_psg: List[str | Any], template: str | Path
) -> list[PromptMessage]:
    template: Template = load_prompt_template(template)
    ret = []
    for q, psg in zip(q_ls, ret_psg):
        passage_text = "\n".join(psg)
        p = template.render(question=q, documents=passage_text)
        ret.append(p)
    return ret
```

### Step 3: Use the Tool in the Pipeline

1. Register the Prompt Server and invoke your implemented Tool in the YAML configuration file:

```yaml servers/prompt/parameter.yaml icon="/images/yaml.svg"
# MCP Server
servers:
  generation: servers/generation
  prompt: servers/prompt

# MCP Client Pipeline
pipeline:
- prompt.qa_rag_boxed
- generation.generate
```

2. After building, modify the runtime parameters to specify the path to your template file:

```yaml servers/prompt/parameter.yaml icon="/images/yaml.svg"
prompt:
  template: prompt/qa_rag_boxed.jinja
```

## Bind Different Templates for Multiple Tools

```python servers/prompt/src/prompt.py icon="python"
@app.prompt(output="q_ls,ret_psg,template1->prompt_ls")
def qa_rag_boxed(
    q_ls: List[str], ret_psg: List[str | Any], template: str | Path
) -> list[PromptMessage]:
    xxxx

@app.prompt(output="q_ls,ret_psg,template2->prompt_ls")
def qa_rag_boxed_2(
    q_ls: List[str], ret_psg: List[str | Any], template: str | Path
) -> list[PromptMessage]:
    xxxx
```
Bind template paths to the two tools above by adding the following to `servers/prompt/parameter.yaml`:

```yaml servers/prompt/parameter.yaml icon="/images/yaml.svg"
template1: prompt/qa_boxed.jinja
template2: prompt/qa_boxed.jinja
```

This ensures that different tools use independent templates during execution without interfering with each other.