---
title: "Understanding RAG Server"
icon: "books"
---

## What is a Server?

In traditional RAG systems, we usually break down the system into multiple functional modules, such as Retriever, Generator, etc. These modules take on different tasks and, through workflow orchestration, collaboratively complete complex QA and reasoning tasks.

In UltraRAG 2.0, we encapsulate such modules under the MCP (Model Context Protocol) architecture and propose a more standardized implementationâ€”Server.

> A Server is essentially an independent RAG module component with its own functionality.

Each Server encapsulates the core task logic (such as retrieval, generation, evaluation, etc.), and provides standardized interfaces via tool functions (Tool), supporting flexible scheduling and combination within the full reasoning pipeline.

## Quick Start: Develop a Server Using the Calculator Example

To help you understand how to use a Server, we will use a simple "Calculator" module as an example to demonstrate the full development process of a Server.

### Step 1: Create the Calculator Server

First, instantiate a Server named `calculator` via `UltraRAG_MCP_Server`:

```python
# servers/calculator/src/calculator.py

from ultrarag_mcp.server import UltraRAG_MCP_Server

app = UltraRAG_MCP_Server("calculator")

if __name__ == "__main__":
    app.run(transport="stdio")
```

### Step 2: Implement Tool Functions

Register tool functions using the `@app.tool` decorator. These functions will be called in the Pipeline.

```python
from ultrarag_mcp.server import UltraRAG_MCP_Server

app = UltraRAG_MCP_Server("calculator")

@app.tool(output="a,b->result")
def add(a: float, b: float) -> Dict[str, float]:
    """Return the sum of a and b"""
    return {"result": a + b}

@app.tool(output="result")
def minus(a: float, b: float) -> Dict[str, float]:
    """Return a - b"""
    return {"result": a - b}
    
@app.tool(output="a,b->None")
def log(a: float, b: float) -> None:
   """Logging a, b"""
   app.logger.info(f"a: {a}, b:{b}")

if __name__ == "__main__":
    app.run(transport="stdio")
```

### Step 3: Configure the Parameter File

Create the parameter configuration file `servers/calculator/parameter.yaml` to specify parameters and inject default values:

```yaml
# servers/calculator/parameter.yaml
a: 1
b: 2
```

### Encapsulate as a Class to Support State Management

In some scenarios, we may want to maintain shared state or variables within the Server, such as initializing a model. In this case, the Server can be wrapped as a class. Here is an example of encapsulating the Calculator Server as a class:

```python
from ultrarag_mcp.server import UltraRAG_MCP_Server

app = UltraRAG_MCP_Server("calculator")

class Calculator:
    def __init__(self, mcp_inst: UltraRAG_MCP_Server):
        mcp_inst.tool(self.add, output="b->result")
        mcp_inst.tool(self.minus, output="result")
        mcp_inst.tool(self.log, output="none")
        self.a = 10  # Simulate a global variable
        
    def add(self, b: float) -> Dict[str, float]:
        return {"result": self.a + b}
        
    def minus(self, b: float) -> Dict[str, float]:
        return {"result": self.a - b}
    
    def log(self, b: float):
        app.logger.info(f"a: {self.a}, b:{b}")
 
if __name__ == "__main__":
    Calculator(app)
    app.run(transport="stdio")
```

The above content demonstrates how to develop a custom Server and implement its tool functions (Tool). You can use this approach to encapsulate any functionality as a module component and combine and call them in UltraRAG's Pipeline.

In the following sections, we will introduce several of the most commonly used built-in Servers in UltraRAG to help you quickly build your own RAG workflow.